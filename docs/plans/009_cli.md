## 0) What we already have (and will reuse)

* **Setup/Simulation lifecycle**

  * `System.setup()` phase context manager to separate initialization from simulation.&#x20;
  * `run_day(system)` and `run_until_stable(system, ...)` to drive daily phases and stopping conditions (quiet days & no open obligations).&#x20;

* **Operations to build scenarios**

  * Cash & reserves: `mint_cash`, `transfer_cash`, `mint_reserves`, `transfer_reserves`, conversions.&#x20;
  * Banking ops: `deposit_cash`, `withdraw_cash`, `client_payment`.&#x20;
  * Stocks & deliveries: `create_stock`, `transfer_stock`, `create_delivery_obligation`. (Old `Deliverable` exists but is deprecated; we‚Äôll hide it in the UI.)&#x20;
  * Settlement/Clearing engines for due payables & delivery obligations and interbank nets.&#x20;

* **Display & diagnostics**

  * Balance tables for agents and side‚Äëby‚Äëside comparisons, plus system trial balances (`analysis/visualization.py`, `analysis/balances.py`).&#x20;
  * Event display helpers (`display_events`, `display_events_for_day`) and event kinds produced by engines/ops.&#x20;
  * Invariant checks and structured exceptions: `ValidationError`, `DefaultError`, etc.&#x20;

These are exactly the primitives we‚Äôll expose via a minimal configuration format and a thin CLI UI.

---

## 1) V1.0 Outcomes

**As a domain expert**, I can:

1. **Create** a scenario via a small YAML (or fill a wizard) that describes:

   * Agents (central bank, banks, firms, households, treasury)
   * Initial mints (cash/reserves), deposits, stocks (inventory lots), delivery/payable obligations (with due days), and optional policy overrides
2. **Load** that scenario and **run** the simulation:

   * Step day‚Äëby‚Äëday or `--until-stable`
3. **See clearly**:

   * **Balances** by agent and system trial balance
   * **Events** per day in summary or detailed form
   * **Errors & issues** (e.g., defaults, failed transfers, invariant violations) with helpful context
4. **Export** a simple CSV/JSON of balances over time and a JSONL of event logs for paper writing.

---

## 2) Configuration Layer (simple, explicit, YAML-first)

### 2.1 File format (YAML)

* Keep it small and explicit; mirror your domain ops to minimize translation.
* Use **PyYAML** for parsing and **pydantic v2** (or dataclasses + custom validation) for clean error messages.

**Schema (V1.0)**

```yaml
version: 1
name: "Two Banks, Households, Delivery"
description: "Example used in paper"

policy_overrides:
  # optional: override default settlement order per agent kind
  mop_rank:
    household: ["bank_deposit", "cash"]
    bank: ["reserve_deposit"]

agents:
  - id: CB1
    kind: central_bank
    name: Central Bank
  - id: B1
    kind: bank
    name: Bank One
  - id: B2
    kind: bank
    name: Bank Two
  - id: H1
    kind: household
    name: Household 1
  - id: H2
    kind: household
    name: Household 2
  - id: F1
    kind: firm
    name: Machines Inc.

initial_actions:
  # all run inside System.setup() before day 0
  - mint_reserves: {to: B1, amount: 1000}
  - mint_reserves: {to: B2, amount: 1000}
  - mint_cash: {to: H1, amount: 1500}
  - mint_cash: {to: H2, amount: 500}
  - deposit_cash: {customer: H1, bank: B1, amount: 1200}
  - create_stock: {owner: F1, sku: MACHINE, quantity: 10, unit_price: "1000"}
  - create_delivery_obligation: {from: F1, to: H1, sku: MACHINE, quantity: 2, unit_price: "1000", due_day: 1}
  - create_payable: {from: H1, to: H2, amount: 300, due_day: 0}  # convenience wrapper to create a Payable

run:
  mode: until_stable      # or: step
  max_days: 90
  quiet_days: 2
  show:                   # default display preferences
    balances: ["CB1", "B1", "B2", "H1", "H2", "F1"]
    events: detailed      # or: summary
  export:
    balances_csv: "out/balances.csv"
    events_jsonl: "out/events.jsonl"
```

**Notes**

* `create_payable` is a thin convenience wrapper that constructs a `Payable` instrument; settlement logic is already in Phase B.&#x20;
* `create_delivery_obligation` maps directly to `System.create_delivery_obligation` (the new, preferred path after separating inventory from bilateral obligations).&#x20;
* All `initial_actions` run under `System.setup()`, so these operations are clearly separated from simulation days.&#x20;

### 2.2 Internal config model (pydantic/dataclasses)

Create `bilancio/config/`:

* `models.py` ‚Äî `ScenarioConfig`, sub‚Äëmodels for `PolicyOverrides`, `AgentSpec`, `Action` unions (`MintReserves`, `MintCash`, `DepositCash`, `CreateStock`, `CreateDeliveryObligation`, `CreatePayable`).
* `loaders.py` ‚Äî `load_yaml(path) -> ScenarioConfig`.
* `apply.py` ‚Äî `apply_to_system(cfg, system)`:

  * Instantiates agents
  * Applies policy overrides (mutate `PolicyEngine.mop_rank`)
  * Executes `initial_actions` **inside** `system.setup()` using the existing ops:

    * `mint_reserves`, `mint_cash` (System)&#x20;
    * `deposit_cash` (ops.banking)&#x20;
    * `create_stock`, `create_delivery_obligation` (System)&#x20;
    * `create_payable` (new helper that constructs a `Payable` and `add_contract`)&#x20;
  * After each action: optionally `system.assert_invariants()`; failures will be surfaced with context.&#x20;

---

## 3) Minimal, Legible Interface (CLI + Rich)

We‚Äôll add a tiny CLI (`bilancio-cli`) with **two commands** that domain experts can run from a terminal:

### 3.1 Commands

* `bilancio run <scenario.yaml> [--step | --until-stable] [--max-days N] [--quiet-days Q] [--show events|summary|detailed] [--agents A,B,...]`

  * Loads config ‚Üí builds system ‚Üí runs either day‚Äëby‚Äëday (prompting to continue) or until stable.
  * After each day:

    * Prints **events** (`display_events` or `display_events_for_day`) and **selected balances** using the existing visualization helpers.&#x20;
    * Shows **system trial balance** or an aggregated table (via `analysis.balances.as_rows`) if `--agents` omitted.&#x20;
  * On **errors** (see ¬ß4), shows a prominent panel with the error, what failed, and where to look.

* `bilancio new [--from TEMPLATE] -o scenario.yaml`

  * Wizard that asks a few high‚Äëlevel questions and writes a starter YAML.
  * Keep choices guarded to the subset we support in V1.0.

**Implementation**: `click` for CLI + `rich` for tables/panels that mirror your existing console style (you already depend on `rich` in visualization).&#x20;

### 3.2 What users see (typical run)

* Header: scenario name + description
* **Day 0**: (after setup) optional snapshot
* For each day:

  * **Events** (grouped by day, summary/detailed)
  * **Balances**:

    * Per selected agents: `display_agent_balance_table(system, agent_id, format='rich')`
    * Or compact side‚Äëby‚Äëside: `display_multiple_agent_balances`
    * Optional: short **SYSTEM** trial balance row (assets=liabilities check) via `system_trial_balance` / `as_rows`.&#x20;
* Footer per day: **phase recap** (A/B/C) and **impacted count** (from `DayReport`).&#x20;

> **Small fix for clarity**: enhance `display_events` to show ‚ÄúüìÖ Setup Phase‚Äù by looking at `event["phase"] == "setup"` (today it keys on `day == -1`, which isn‚Äôt how `System.log` records setup). Add this in the visualization module.&#x20;

---

## 4) Errors, Issues, and Diagnostics (first‚Äëclass)

The interface should make problems **visible and actionable** to a non‚Äëengineer.

* **Structured exceptions**: Catch `ValidationError`, `DefaultError`, plus generic `Exception`. Show a **Rich panel** with:

  * Error kind and message
  * If during **setup**: show the **action** that failed and its YAML snippet
  * If during **day t**: show the **phase** (A/B/C), the **instrument/agents** involved
  * A short ‚ÄúWhat it usually means‚Äù tip (e.g., DefaultError ‚Üí debtor lacks sufficient means).
  * Offer to **print invariants** status or **dump a state snapshot** to a temp file.&#x20;

* **Log errors into events**: when catching, also `system.log("Error", type="ValidationError", context=..., message=...)` so that the day‚Äôs timeline reflects the failure (prevents ‚Äúsilent fail‚Äù).&#x20;

* **Invariant guardrails**:

  * Option `--check-invariants [setup|daily|none]` controls when `system.assert_invariants()` is run; failures show a categorized message (duplicate refs, CB counters mismatch, negative balances/stocks) with a short explanation.&#x20;

* **Exports**:

  * `events.jsonl`: append one JSON per event (`system.state.events` item) for forensic re‚Äëuse.
  * `balances.csv`: use `analysis.balances.as_rows(system)` per day to emit a tidy table.&#x20;

---

## 5) Modules & Files to Add

```
src/bilancio/
  config/
    __init__.py
    models.py            # pydantic/dataclass models for ScenarioConfig and Actions
    loaders.py           # load_yaml() with validation & nice errors
    apply.py             # apply_to_system(cfg, system) using System.setup() + existing ops
  ui/
    __init__.py
    cli.py               # click-based CLI ("bilancio" console script)
    run.py               # orchestration: load ‚Üí apply ‚Üí run (step/until-stable)
    display.py           # thin wrappers: pick 'summary' vs 'detailed', table layout choices
  export/
    __init__.py
    writers.py           # balances_csv(), events_jsonl() built on existing analysis APIs
```

* **pyproject**: add console\_script `bilancio = bilancio.ui.cli:main`.

* **Small change** in `analysis/visualization.py`: teach `display_events` to respect `event["phase"] == "setup"` when labeling the Setup section.&#x20;

---

## 6) Orchestration Flow (pseudo‚Äëcode)

```python
# ui/run.py
def run_scenario(path, mode, max_days, quiet_days, show, agent_ids, check_invariants, export):
    cfg = load_yaml(path)                          # config.loaders
    system = System()                              # engines.system
    apply_to_system(cfg, system)                   # config.apply  (uses System.setup())
    if check_invariants in ("setup", "daily"): 
        system.assert_invariants()

    # select display prefs from cfg unless overridden
    selection = agent_ids or cfg.run.show.balances
    events_mode = show or cfg.run.show.events

    if mode == "step":
        while True:
            render_day_header(system.state.day, cfg.name)
            show_day(system, selection, events_mode)   # display helpers, uses analysis.visualization
            ok = prompt_continue()                     # hit enter to run next day
            if not ok: break
            try:
                run_day(system)                        # engines.simulation
            except BilancioError as e:
                record_and_render_error(system, e)     # log + panel
                break
            if check_invariants == "daily":
                system.assert_invariants()
    else:
        try:
            reports = run_until_stable(system, max_days=max_days, quiet_days=quiet_days)
        except BilancioError as e:
            record_and_render_error(system, e)
        finally:
            render_summary(reports, system)            # show final balances/events

    # Exports
    maybe_write_balances_csv(system, export.balances_csv)
    maybe_write_events_jsonl(system, export.events_jsonl)
```

**All the heavy lifting remains in your existing engines/ops/analysis modules.**&#x20;

---

## 7) Tests (high‚Äëleverage, low‚Äëceremony)

Add a small suite under `tests/ui/` and `tests/config/`:

* **Config round‚Äëtrip**: load example YAMLs ‚Üí `apply_to_system` ‚Üí `system.assert_invariants()` passes; counts of agents, stocks, contracts match expectations.&#x20;
* **Happy paths**: run `--until-stable` on 2‚Äì3 scenarios, assert:

  * Final **no open obligations**, quiet days achieved;
  * **Interbank** net clearing occurred when expected; **overnight** payables appear when reserves insufficient. (Mirror existing integration tests‚Äô logic.)&#x20;
* **Error surfacing**: invalid action (e.g., withdraw with no deposit) produces a visible CLI error and an `Error` event; process exits cleanly.&#x20;
* **Exports**: CSV/JSONL created and non‚Äëempty; columns match `as_rows` output.&#x20;

---

## 8) Acceptance Criteria (for V1.0 sign‚Äëoff)

* **Create/Load/Run**: I can run `bilancio run scenario.yaml --until-stable` and see:

  * A per‚Äëday event log (summary or detailed), balances for selected agents, and a system trial balance check.&#x20;
* **Visibility of issues**:

  * If a debtor cannot settle, I see a clear **DefaultError panel**, the offending obligation, and the day/phase.&#x20;
  * If invariants fail, I see which invariant failed and a short human explanation (e.g., ‚Äúduplicate asset ref‚Äù).&#x20;
* **Exports**: `out/balances.csv` (one row per agent per day + system) and `out/events.jsonl` are generated and parsable for paper figures.&#x20;
* **No new concepts** exposed to the domain user beyond agents, deposits/cash/reserves, stocks, payables & delivery obligations, and due days.

---

## 9) Roadmap (post‚ÄëV1.0, optional but enabled by this design)

* **Timeline actions** beyond setup: allow a `timeline:` block to schedule future actions (e.g., new obligations on day 5).
* **Parameter sweeps / Monte Carlo**: wrap scenarios in `MonteCarloEngine` with a tiny config for distributions; write a CSV of summary stats.&#x20;
* **Notebook ‚Äúlab‚Äù**: ship a single ready‚Äëto‚Äërun notebook that loads a YAML, runs, and uses the same display helpers (you already have demo notebooks to crib from).&#x20;
* **Richer TUI**: if desired later, a `textual` UI that shows day timeline on the left and agent balances on the right, reusing the same display functions.

---

## 10) Work Breakdown (for the coding agent)

* **Config layer**

  * `config/models.py` (pydantic models)
  * `config/loaders.py` (YAML ‚Üí models, nice error messages)
  * `config/apply.py` (maps actions to existing ops inside `System.setup()`; optional invariant checks) &#x20;
* **CLI & display**

  * `ui/cli.py` (click entrypoint), `ui/run.py` (orchestration), `ui/display.py` (thin wrappers)
  * Improve `display_events` to respect `event["phase"]=="setup"`.&#x20;
* **Exports**

  * `export/writers.py`: `write_balances_csv(system)` using `analysis.balances.as_rows(system)`; `write_events_jsonl(system)` from `state.events`.&#x20;
* **Error surfaces**

  * Wrap setup and day runs with try/except for `ValidationError`/`DefaultError`, log `Error` events, render panels.&#x20;
* **Tests & examples**

  * `tests/config/test_apply_basic.py`, `tests/ui/test_cli_until_stable.py`
  * `examples/scenarios/*.yaml` (1‚Äì3 curated scenarios used in tests)

---

If you‚Äôd like, I can draft the **exact pydantic models, the action‚Äëto‚Äëops mapping table, and the CLI argument spec**, but the outline above is enough for an advanced agent to implement directly using your current APIs. All pieces intentionally route through existing functions (engines/ops/analysis), so the new layer remains thin, transparent, and extensible.&#x20;
