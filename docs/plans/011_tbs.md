Below is a concrete, end‑to‑end implementation plan to upgrade Bilancio’s display layer to a **row‑based T‑account** with clear event tables and full disaggregation. I’ve tied each change to specific files/functions already in your repo so an advanced coding agent can implement it directly.

> **Scope recap**
>
> 1. T‑account layout (assets left, liabilities right).
> 2. Row schema per line item: **Name**, **Quantity**, **Monetary value**, **Counterparty**, **Maturity/due date**.
> 3. Event tracking in **tabular** form.
> 4. **Disaggregate** entries: no bundling; every contract/lot is its own row.

Everything below aligns with the current codebase structure and visualization flows (Rich console, CLI, and HTML export).&#x20;

---

## A. Data model: add row‑level balance entries (analysis layer)

**Why**: The current `AgentBalance` aggregates amounts by kind, which is great for totals but cannot render per‑contract rows with counterparty/maturity. We’ll introduce a normalized **row entity** that is derived from system state each time we display.

**Files & changes**

1. `src/bilancio/analysis/balances.py`
   Add new dataclasses and a builder:

```python
# --- NEW: Row-level view types ---
from dataclasses import dataclass
from typing import Optional, Literal
from decimal import Decimal

@dataclass
class BalanceRow:
    side: Literal["asset", "liability"]         # T-account side
    instrument_id: str                          # contract/stock id
    kind: str                                   # e.g., 'bank_deposit', 'payable', 'delivery_obligation', 'stock_lot'
    name: str                                   # human label for the row
    quantity: Optional[int]                     # units for goods; None for pure money
    value_minor: Optional[int]                  # money in minor units (cents); for goods: valued_amount as int
    denom: Optional[str]                        # 'X' or N/A for goods
    sku: Optional[str]                          # for goods/delivery obligations
    counterparty_id: Optional[str]              # issuer (for asset) or holder (for liability); None for stock
    counterparty_name: Optional[str]            # resolved friendly name
    maturity: Optional[str]                     # "on-demand" or f"Day {due_day}"

@dataclass
class AgentTAccount:
    agent_id: str
    assets: list[BalanceRow]
    liabilities: list[BalanceRow]
```

Add a **builder** that produces rows by scanning the agent’s actual contracts and stocks:

```python
def build_t_account_rows(system: System, agent_id: str) -> AgentTAccount:
    agent = system.state.agents[agent_id]
    assets: list[BalanceRow] = []
    liabilities: list[BalanceRow] = []

    # Helper to resolve agent labels
    def label(aid: str) -> str:
        a = system.state.agents.get(aid)
        return f"{(a.name or aid)} [{aid}]" if a else aid

    # 1) Inventory (stock_lot) – assets only, no counterparty/maturity
    for stock_id in agent.stock_ids:
        stock = system.state.stocks[stock_id]
        name = f"{stock.sku} [inventory]"
        assets.append(BalanceRow(
            side="asset",
            instrument_id=stock_id,
            kind=stock.kind,
            name=name,
            quantity=stock.quantity,
            value_minor=int(stock.value),     # value = qty * unit_price (Decimal) → int minor units for display
            denom="X",
            sku=stock.sku,
            counterparty_id=None,
            counterparty_name=None,
            maturity="—",
        ))

    # 2) Contracts where agent is holder → asset rows
    for cid in agent.asset_ids:
        c = system.state.contracts[cid]
        # Counterparty is the issuer
        cpty = c.liability_issuer_id
        due = getattr(c, "due_day", None)
        maturity = f"Day {due}" if due is not None else "on-demand"
        quantity = None
        value_minor = c.amount
        name = c.kind

        # delivery_obligation (asset side = receivable of goods): show units and monetary value
        if c.kind == "delivery_obligation":
            sku = getattr(c, "sku", "N/A")
            unit_price = getattr(c, "unit_price", None)
            name = f"{sku} receivable"
            quantity = c.amount
            # valued_amount is Decimal → cast to int minor units for display
            value_minor = int(getattr(c, "valued_amount"))
            denom = "X"
            assets.append(BalanceRow("asset", cid, c.kind, name, quantity, value_minor, denom, sku,
                                     cpty, label(cpty), f"Day {due}"))
            continue

        # financial assets (cash/bank_deposit/reserve_deposit/payable-as-asset)
        denom = getattr(c, "denom", "X")
        assets.append(BalanceRow("asset", cid, c.kind, name, quantity, value_minor, denom, None,
                                 cpty, label(cpty), maturity))

    # 3) Contracts where agent is issuer → liability rows
    for cid in agent.liability_ids:
        c = system.state.contracts[cid]
        # Counterparty is the holder
        cpty = c.asset_holder_id
        due = getattr(c, "due_day", None)
        maturity = f"Day {due}" if due is not None else "on-demand"
        quantity = None
        value_minor = c.amount
        name = c.kind

        if c.kind == "delivery_obligation":
            sku = getattr(c, "sku", "N/A")
            name = f"{sku} obligation"
            quantity = c.amount
            value_minor = int(getattr(c, "valued_amount"))
            denom = "X"
            liabilities.append(BalanceRow("liability", cid, c.kind, name, quantity, value_minor, denom, sku,
                                          cpty, label(cpty), f"Day {due}"))
            continue

        denom = getattr(c, "denom", "X")
        liabilities.append(BalanceRow("liability", cid, c.kind, name, quantity, value_minor, denom, None,
                                      cpty, label(cpty), maturity))

    return AgentTAccount(agent_id=agent_id, assets=assets, liabilities=liabilities)
```

> This builder uses the existing state layout and instruments (cash, deposits, reserves, payables, delivery obligations, stock lots) as implemented across `engines/system.py`, `domain/instruments/*`, and `domain/goods.py`. The code also respects due days and valued non‑financial amounts already introduced in recent commits.&#x20;

**Notes**

* We **do not** change `AgentBalance`/`TrialBalance`; keep them for totals. The T‑account rows are an additional view.
* `value_minor` always contains a money amount in **minor units** (int) for formatting consistency (goods are pre‑valued into int via Decimal → int conversion, i.e., cents).

---

## B. Rich console T‑account renderer (side‑by‑side, row‑based)

**Why**: Current `_display_rich_agent_balance` shows a 2×2 table (name/amount), not five columns per side. We’ll add a new renderer that prints **ten columns**: 5 for assets, 5 for liabilities.

**Files & changes**

2. `src/bilancio/analysis/visualization.py`

* Keep existing functions for backward compatibility.
* **Add** a new set:

```python
def display_agent_t_account(
    system: System,
    agent_id: str,
    format: str = "rich",
    title: str | None = None
) -> None:
    """
    Render a T-account with row-level detail:
    Left (Assets): Name | Qty | Value | Counterparty | Maturity
    Right (Liabilities): Name | Qty | Value | Counterparty | Maturity
    """
    acct = build_t_account_rows(system, agent_id)

    if format == "rich" and RICH_AVAILABLE:
        _display_rich_t_account(system, acct, title=title)
    else:
        _display_simple_t_account(system, acct, title=title)
```

* Implement the Rich table (10 columns):

```python
def _display_rich_t_account(system: System, acct: AgentTAccount, title: str | None):
    console = Console()
    agent = system.state.agents[acct.agent_id]
    if not title:
        title = f"{(agent.name or acct.agent_id)} [{acct.agent_id}] ({agent.kind})"

    table = Table(title=title, box=box.ROUNDED, title_style="bold cyan")
    # Assets columns
    table.add_column("ASSET", style="green", no_wrap=False)
    table.add_column("Qty", justify="right", style="green", no_wrap=True)
    table.add_column("Value", justify="right", style="green", no_wrap=True)
    table.add_column("Counterparty", style="green", no_wrap=False)
    table.add_column("Maturity", style="green", no_wrap=True)
    # Liabilities columns
    table.add_column("LIABILITY", style="red", no_wrap=False)
    table.add_column("Qty", justify="right", style="red", no_wrap=True)
    table.add_column("Value", justify="right", style="red", no_wrap=True)
    table.add_column("Counterparty", style="red", no_wrap=False)
    table.add_column("Maturity", style="red", no_wrap=True)

    # Equalize row count and print
    max_rows = max(len(acct.assets), len(acct.liabilities))
    for i in range(max_rows):
        a = acct.assets[i] if i < len(acct.assets) else None
        l = acct.liabilities[i] if i < len(acct.liabilities) else None

        def fmt_qty(r): return f"{r.quantity:,}" if (r and r.quantity is not None) else "—"
        def fmt_val(r):
            if not r or r.value_minor is None: return "—"
            return _format_currency(int(r.value_minor))
        def cells(r):
            if not r: return ("", "", "", "", "")
            return (r.name, fmt_qty(r), fmt_val(r), r.counterparty_name or "—", r.maturity or "—")

        table.add_row(*cells(a), *cells(l))

    console.print(table)
```

* Implement the simple (ASCII) fallback `_display_simple_t_account` analogous to `_display_simple_agent_balance`, with 10 “columns” separated by `|`, trimming text as needed.

* **Keep** old `display_agent_balance_table` and `display_multiple_agent_balances` as-is to avoid breaking notebooks/tests; we can later migrate them to call the new T‑account renderer behind a flag.

> The Rich integration and table assembly follow the patterns already in `analysis/visualization.py` for both simple and rich modes.&#x20;

---

## C. Event tracking: add tabular views

**Why**: The code already prints great narrative event logs with emojis (`display_events`, `_display_events_detailed`), but we need a compact **table** that shows “what changed” at each step.

**Files & changes**

3. `src/bilancio/analysis/visualization.py`

Add:

```python
def display_events_table(events: list[dict], group_by_day: bool = True) -> None:
    """Render events as a table with canonical columns."""
    console = Console() if RICH_AVAILABLE else None

    columns = ["Day", "Phase", "Kind", "From", "To", "SKU/Instr", "Qty", "Amount", "Notes"]

    if RICH_AVAILABLE:
        from rich.table import Table; from rich import box
        table = Table(title="Events", box=box.SIMPLE_HEAVY)
        for c in columns: table.add_column(c, no_wrap=False, justify="left")
        evs = sorted(events, key=lambda e: (e.get("day", -1), e.get("phase",""), e.get("kind","")))
        for e in evs:
            kind = e.get("kind","")
            frm = e.get("frm") or e.get("from") or e.get("debtor") or e.get("payer")
            to  = e.get("to")  or e.get("creditor") or e.get("payee")
            sku = e.get("sku") or e.get("instr_id") or e.get("stock_id") or "—"
            qty = e.get("qty") or e.get("quantity") or "—"
            amt = e.get("amount") or "—"
            notes = ""
            if kind == "ClientPayment":
                notes = f"{e.get('payer_bank','?')} → {e.get('payee_bank','?')}"
            elif kind in ("InterbankCleared","InterbankOvernightCreated"):
                notes = f"{e.get('debtor_bank','?')} → {e.get('creditor_bank','?')}; due {e.get('due_day','—') if 'due_day' in e else '—'}"
            table.add_row(str(e.get("day","—")), e.get("phase","—"), kind, str(frm or "—"), str(to or "—"),
                          str(sku), str(qty), str(amt), notes)
        console.print(table) if console else print(table)
    else:
        # Simple header + rows
        header = " | ".join(columns)
        print(header); print("-"*len(header))
        for e in sorted(events, key=lambda e: (e.get("day", -1), e.get("phase",""), e.get("kind",""))):
            # same mappings as above
            ...
```

4. `src/bilancio/ui/display.py`

* Extend the `event_mode` switch to accept `"table"` and call `display_events_table`:

```python
# in show_day_summary(...)
if event_mode == "table":
    display_events_table(events_for_day)
elif event_mode == "detailed":
    display_events(events_for_day, format="detailed")
else:
    # 'summary' branch unchanged
```

5. `src/bilancio/ui/cli.py` and `src/bilancio/config/models.py`

* Add `"table"` to the allowed choices for event display:

```python
# CLI
@click.option('--show', type=click.Choice(['summary', 'detailed', 'table']),
              default='detailed', help='Event display mode')

# Pydantic
class ShowConfig(BaseModel):
    events: Literal["summary", "detailed", "table"] = Field("detailed", ...)
```

> The new table depends only on fields already logged by the system in `engines/*` and by ops (`ClientPayment`, `ReservesTransferred`, `StockTransferred`, etc.). No engine changes required.&#x20;

---

## D. HTML export: grid T‑account with row‑based entries

**Why**: The current HTML export preserves the Rich‑style output; we’ll add a semantic HTML/CSS T‑account that mirrors the console table visually and structurally.

**Files & changes**

6. `src/bilancio/ui/html_export.py`
   Add helpers to render one agent:

```python
def render_t_account_html(system: System, agent_id: str) -> str:
    acct = build_t_account_rows(system, agent_id)
    agent = system.state.agents[agent_id]
    title = f"{(agent.name or agent_id)} [{agent_id}] ({agent.kind})"

    def tr(row: BalanceRow) -> str:
        qty = f"{row.quantity:,}" if row.quantity is not None else "—"
        val = f"{int(row.value_minor):,}" if row.value_minor is not None else "—"
        cpty = row.counterparty_name or "—"
        mat  = row.maturity or "—"
        return f"""
          <tr>
            <td class="name">{row.name}</td>
            <td class="qty">{qty}</td>
            <td class="val">{val}</td>
            <td class="cpty">{cpty}</td>
            <td class="mat">{mat}</td>
          </tr>
        """

    return f"""
<section class="t-account">
  <h3>{title}</h3>
  <div class="grid">
    <div>
      <h4>Assets</h4>
      <table class="side">
        <thead><tr><th>Name</th><th>Qty</th><th>Value</th><th>Counterparty</th><th>Maturity</th></tr></thead>
        <tbody>
          {''.join(tr(r) for r in acct.assets)}
        </tbody>
      </table>
    </div>
    <div>
      <h4>Liabilities</h4>
      <table class="side">
        <thead><tr><th>Name</th><th>Qty</th><th>Value</th><th>Counterparty</th><th>Maturity</th></tr></thead>
        <tbody>
          {''.join(tr(r) for r in acct.liabilities)}
        </tbody>
      </table>
    </div>
  </div>
</section>
"""
```

Add CSS (at top of the HTML export or injected stylesheet):

```css
.t-account .grid {
  display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
}
.t-account table.side {
  width: 100%; border-collapse: collapse; font-size: 0.95rem;
}
.t-account th, .t-account td {
  border-bottom: 1px solid #eee; padding: 6px 8px; vertical-align: top;
}
.t-account th { text-align: left; }
.t-account td.qty, .t-account td.val, .t-account td.mat { text-align: right; white-space: nowrap; }
.t-account h4 { margin: 4px 0 8px; }
```

Integrate this renderer in the existing page assembly where you currently print agent balances after each day. (The repo already builds a colored HTML page and inserts per‑day sections; add or replace the balances area with these semantic tables.)&#x20;

---

## E. Disaggregation defaults & ordering

* **Always disaggregate** rows in the new T‑account: each contract/stock is a row.
* **Ordering** within each side:

  1. Inventory (stock\_lot)
  2. Non‑financial contracts (delivery obligations receivable/obligation) by `due_day` then `sku`
  3. Financial instruments in stable order: `cash`, `bank_deposit`, `reserve_deposit`, `payable`.
* **Labels**:

  * Assets: `"SKU receivable"` for delivery claims; liabilities: `"SKU obligation"`.
  * Counterparty shown as `"Name [ID]"` if available.
  * Maturity: `"on-demand"` for cash/deposits/reserves; `"Day N"` for `payable`/`delivery_obligation`.

---

## F. CLI: enable new views without breaking old ones

7. `src/bilancio/ui/display.py`

* Where you currently show balances at the end of each day, call:

```python
from bilancio.analysis.visualization import display_agent_t_account

# for each agent id to show
display_agent_t_account(system, agent_id, format="rich")
```

* Keep the older tables available (e.g., behind a `--legacy-table` flag in CLI if desired).
* Add the `--show table` option (Section C) so users can pick tabular events.

8. `src/bilancio/ui/cli.py`
   Expose the new events mode and (optionally) a `--t-account` boolean to force new layout if you want a toggle during the transition.

---

## G. Formatting utilities (consistency)

9. `src/bilancio/analysis/visualization.py`

* Promote `_format_currency` so both the new T‑account and legacy tables use it uniformly for ints and Decimal→int values (already present; reuse).
* Add a tiny helper to coerce Decimal `valued_amount` into int minor units before formatting (already implemented as `_format_deliverable_amount`; reuse).&#x20;

---

## H. Tests

**Files & new tests**

* `tests/ui/test_t_account_layout.py`

  * Build a small system (CB, B1, H1, Firm), create: cash, deposit, payable (with due\_day), stock lot, delivery obligation both sides.
  * `capture_console` with Rich recording to assert **headers** and presence of per‑row fields (Name/Qty/Value/Counterparty/Maturity) on both sides.

* `tests/analysis/test_build_t_account_rows.py`

  * Unit test the new builder to ensure:

    * Every contract/stock becomes **one row**.
    * Counterparty & maturity set correctly per instrument kind.
    * Goods rows carry quantity and valued monetary total.

* `tests/ui/test_events_table.py`

  * Feed synthetic events spanning `ClientPayment`, `InterbankCleared`, `StockTransferred`, `DeliveryObligationSettled` and assert the table rows.

> The repo’s existing tests around balances, settlement, clearing and HTML export remain valid; these are additive tests focused on display.&#x20;

---

## I. Backwards compatibility & docs

* Keep **`display_agent_balance_table`** and **`display_multiple_agent_balances`** intact. Optionally make them call the new row builder internally when a `detailed=True` flag is passed.
* Update `README.md` and `docs/plans/006_analytics.md` (or similar) to document:

  * The T‑account columns and semantics (minor units, on‑demand vs due day).
  * CLI: `--show table` to see tabular events.
  * HTML export now shows structured T‑accounts.

---

## J. Acceptance criteria

* For any agent with a mix of instruments, the console and HTML both show a **two‑sided T‑account** with **five columns per side** (Name, Qty, Value, Counterparty, Maturity).
* **No bundling** for display: each instrument/stock lot is a distinct row.
* **Quantities** never appear in the Value column; **money** never appears in Qty.
* **Counterparty** and **Maturity** visible for every bilateral instrument; inventory shows “—”.
* Event view supports `--show table` and renders a compact, sortable table per day.

---

## K. Suggested commit plan (atomic, reviewable)

1. **analysis:** add row dataclasses + `build_t_account_rows()`; unit tests.
2. **viz (rich/simple):** add `display_agent_t_account()` and helpers; snapshot tests.
3. **ui:** wire into CLI and day summaries; add `--show table`; event table renderer + tests.
4. **html\_export:** inject T‑account HTML/CSS; sample output regenerated; docs updated.

---

## L. HTML mock‑up (one agent)

You asked about a mock‑up — here is a minimal HTML/CSS snippet that matches the proposed structure and can drop straight into `html_export`:

```html
<section class="t-account">
  <h3>Consumer A [H1] (household)</h3>
  <div class="grid">
    <div>
      <h4>Assets</h4>
      <table class="side">
        <thead><tr><th>Name</th><th>Qty</th><th>Value</th><th>Counterparty</th><th>Maturity</th></tr></thead>
        <tbody>
          <tr><td>machines [inventory]</td><td>10</td><td>50,000</td><td>—</td><td>—</td></tr>
          <tr><td>bank_deposit</td><td>—</td><td>3,500</td><td>Bank North [B1]</td><td>on-demand</td></tr>
          <tr><td>widgets receivable</td><td>5</td><td>2,500</td><td>Firm Z [F1]</td><td>Day 2</td></tr>
        </tbody>
      </table>
    </div>
    <div>
      <h4>Liabilities</h4>
      <table class="side">
        <thead><tr><th>Name</th><th>Qty</th><th>Value</th><th>Counterparty</th><th>Maturity</th></tr></thead>
        <tbody>
          <tr><td>payable</td><td>—</td><td>1,200</td><td>Merchant Q [M1]</td><td>Day 1</td></tr>
          <tr><td>widgets obligation</td><td>2</td><td>1,000</td><td>Firm Z [F1]</td><td>Day 3</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</section>
<style>
.t-account .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.t-account table.side { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
.t-account th, .t-account td { border-bottom: 1px solid #eee; padding: 6px 8px; }
.t-account td:nth-child(2), .t-account td:nth-child(3), .t-account td:nth-child(5) { text-align: right; white-space: nowrap; }
</style>
```

---

## M. Edge cases & details to watch

* **Multiple deposits** at same bank: your ops coalesce deposits already; still, the builder will list whatever exists in `asset_ids`/`liability_ids`.&#x20;
* **Zero‑valued goods**: allowed but display “0” in Value.
* **Missing names**: fall back to IDs; always print `[ID]`.
* **Long names**: Rich will wrap; simple fallback should truncate with ellipses.
* **Ordering**: deterministic sort as described in Section E.
* **Minor units**: keep everything in minor units for consistency; only **display** converts to readable strings.

---

If you’d like, I can also draft small diff‑style patches for each file to accelerate implementation, but the above should be sufficient for an autonomous coding agent to complete the work.

*(Plan based on current repository layout, display functions, and HTML export code paths documented in your codebase.)*&#x20;
